## ZooKeeper (动物饲养员/管理员)

### **一、ZK简要介绍**

ZooKeeper是一个类似HDFS的树形文件结构，可以用来保证数据在（ZK）集群之间的数据的事务性一致。

ZooKeeper有watch事件，是一次性触发的，当watch监视的数据发生变化时，通知设置了该watch的client，即watcher。

ZooKeeper有三个角色：Learner, Follower, Observer

ZooKeeper应用场景：
- 统一命名服务（Name Service)
- 配置管理（Configuration Management）
- 集群管理（Group Membership）
- 共享锁（Locks）
- 队列管理

ZooKeeper集群搭建注意点（zoo.cfg）：
- data目录
- 服务器配置列表：
```
server.0=master:2888:3888
server.1=slave1:2888:3888
server.2=slave2:2888:3888
```
- myid文件
```
master => 0
slave1 => 1
slave2 => 2
```

zoo.cfg配置文件参数：
- tickTime

基本事件单元，以毫秒为单位。这个时间是作为ZK服务器之间或客户端与服务器之间维持心跳的时间间隔。

- dataDir

存储内存中数据库快照的位置，顾名思义即使ZK保存数据的目录，默认情况下，ZK将些数据的日志文件也保存在这个目录里。

- clientPort

这个端口就是客户端连接ZK服务器的端口，ZK会监听这个端口，接受客户端的访问请求。

- initLimit

这个配置项是用来配置ZK接受客户端初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过10个心跳的时间（也就是tickTime)长度后，ZK服务器还没有接收到客户端的返回信息，那么表示这个客户端连接失败。总的时间长度就是10*2000=20秒

- syncLimit

这个配置项表示Leader与Follower之间发送消息，请求和应答时间长度，最长不能超过多少个tickTime的时间长度，总的时间长度就是5*2000=10秒

server.A = B:C:D
```
A表示这个是第几号服务器，
B是这个服务器的地址
C表示的是这个服务器与集群中的Leader，服务器交换信息的端口
D表示的万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader
```

ZooKeeper命令：
- 启动：``` zkServer.sh start ```
- 状态：``` zkServer.sh status ```
- 连接客户端: ``` zkCli.sh -h 172.0.0.1 ```
```
ls /
ls /zookeeper
create /test zk
get /test
set /test new_zk
```

Note: 创建结点类型有两种，短暂（ephemeral)，持久（persistent)

### **二、ZK应用场景剖析**

ZooKeeper是一个<strong>高可用的分布式数据管理与系统协调框架。</strong>基于对Paxos算法的实现，使该框架保证了分布式环境中数据的强一致性，也正是基于这样的特性，使得ZK解决很多分布式问题。

值得注意的是，ZK并非天生就是为这些应用场景设计的，都是后来众多开发者根绝其框架的特性，利用其提供的一系列API接口（或者成为原语集），摸索出来的典型使用方法。

#### **1.命名服务（Naming Service)**

命名服务是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。

被命名的实体通常可以是集群中的机器，提供的服务地址，远程对象等 —— 这些我们都可以通常他们为名字（Name）。

其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建结点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。

e g:

阿里开源的分布式服务框架 ` Dubbo ` 中使用ZK来作为其命名服务，维护全局的服务地址列表。<br/>
Dubbo实现中：<br/>
- 服务提供者

在服务启动时，向ZK上的指定结点 ` /dubbo/${serviceName}/providers `目录下写入自己的URL地址，这个操作就完成了服务的发布。

- 服务消费者

在服务启动时，订阅 ` /dubbo/${serviceName}/providers `目录下的提供者的URL地址，并向 ` /dubbo/${serviceName}/consumers `目录下写入自己的URL地址。

<strong>Note:</strong>所有向ZK上注册的地址都是临时结点，这样就能够保证服务提供者和消费者能够给自动感应资源的变化。<br/>

另外，Dubbo还有针对服务粒度的监控，方法时订阅 ` /dubbo/${serviceName} `目录下所有提供者和消费者的信息。

#### **2.数据发布与订阅（配置中心）**

发布于订阅模型，即所谓的配置中心，顾名思义就是发布者将数据发布到ZK结点上，供订阅者动态获取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址列表等就非常适合使用。

e g:

- 应用中用到的一些配置信息放到ZK上进行集中管理。这类场景通常是这样：应用在启动的时候回主动来获取一次配置，同时，在结点上注册一个` Watcher `，这样一来，以后每次配置有更新的时候，都会实时通知到订阅的客户端，从而达到获取最新配置信息的目的。

- 分布式搜索服务中，索引的元信息和服务器集群机器的结点状态存放在ZK的一些指定结点，供各个客户端订阅使用。

- 分布式日志手机系统。这个系统的核心工作是收集分布在不同机器的日志。收集器通常是按照应用来分配收集任务单元，因此需要在ZK上创建一个以应用名作为path的结点P，并将这个应用的所有机器ip，以子节点的形式注册到结点P上，这样一来就能够实现机器变动的时候，能够实时感知到收集器调整任务分配。

- 系统中有些信息需要动态获取，并且还会存在人工手动去修改这个信息的发问。通常是暴露出接口，例如JMX接口，来获取一些运行时的信息，引入ZK之后，就不用自己实现一套方案了，只要将这些信息存放到指定的ZK结点上即可。

<strong>Note:</strong>在上面提到的场景中，有个默认前提是：数据量很小，但是数据更新可能会比较快的场景。

#### **3.集群管理与Master选举**

- 集群机器监控

通常用于那种对集群中机器状态、机器在线率有较高要求的场景，能够快速对集群中机器变化做出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。过去的做法通常是：监控系统通过某种手段（比如ping）定时检测每个机器，或者每个机器自己定时向监控系统汇报"我还或者"。这种做法可行，但是存在两个比较明显的问题：
    
- (1)集群中机器有变动的时候，牵连修改的东西比较多
- (2)有一定的延时
    
利用ZK有两个特性，就可以实现另一种集群机器存活性监控系统：

- (1)客户端在结点x上注册一个Watcher，那么如果x的子节点变化了，会通知该客户端
- (2)创建ephemeral类型的结点，一旦客户端和服务器的回话结束或过期，那么该节点就会消失。

例如，监控系统在` /clusterServers `结点下注册一个Watcher，以后每动态加机器，那么就往` /clusterServers `下创建一个ephemeral类型的结点：` /clusterServers/${hostname} `。这样，监控系统就能够实时知道机器的增减情况，至于后续处理就是监控对系统的业务了。

- Master选举（典型ZK应用场景）

在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I/O处理），往往只需要让整个集群中某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能，于是这个master选举便是这种场景下的碰到的主要问题。

利用ZK的强一致性，能够保证在分布式高并发情况下结点创建的全局唯一性，即：同时有多个客户端请求创建` /currentMaster `结点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选取了。

另外，这种场景演化一下，就是动态Master选举。这就要用到ephemeral_sequential类型结点的特性了。上文中提到，所有客户端创建请求，最终只有一个能够给创建成功。在这里稍微变化下，就是允许所有请求都能够创建成功，但是得有个创建顺序，于是所有的请求最终在ZK上创建结果一种可能情况时这样：
` /currentMaster/{sessionId}-1,/currentMaster/{sessionId}-2,/currentMaster/{sessionId}-3 ...... `每次选取序列号最小的那个机器作为Master，如果这个机器挂了，由于他创建的结点马上会消失，那么之后最小的那个机器就是Master了。

e g:

- 在搜索系统中，如果集群中每个机器都生成一份全量索引，不仅耗时，而且不能保证彼此之间索引数据一致。因此让集群中的Master来进行全量索引的生成，然后同步到集群中其他机器。另外，Master选举的容灾措施是，可以随时进行手动指定master，就是说应用在ZK在无法获取master信息时，可以通过比如http方式，向一个地方获取master。

- 在HBase中，也是使用ZK来实现HMaster的选举。在HBase实现中，会在ZK上存储一些ROOT表的地址和HMaster的地址，HRegionServer也会把自己以临时结点（ephemeral）的方式注册到ZK中，使得HMaster可以随时感知到各个HRegionServer的存活状态，同时，一旦HMaster出现问题，会重新选举一个HMaster来运行，从而避免了HMaster的单点问题。

#### **4.分布式锁**

#### **5.分布式队列**

#### **6.分布式通知/协调**

#### **7.负载均衡**